\documentclass[10pt,a4paper,danish]{article}
\usepackage[danish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xfrac}
\usepackage[dot, autosize, outputdir="auto/"]{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{ulem}
\usepackage{subcaption}
\usepackage{mdframed}
\usepackage{color}


\definecolor{verbgray}{gray}{0.92}
\mdfdefinestyle{code}{%
  hidealllines=true,
  backgroundcolor = verbgray}

\let\oldv\verbatim
\let\oldendv\endverbatim

\def\verbatim{\mdframed[style=code]\oldv}
\def\endverbatim{\oldendv\endmdframed}

% \newcommand{\code}[1]{\mdframed[style=code]\texttt{#1}\endmdframed}
% \newcommand{\code}[1]{\texttt{#1}}
\newcommand{\code}[1]{\colorbox{verbgray}{\texttt{#1}}}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\lhead{\nouppercase\leftmark}
\rhead{Den Store AV-bog}
\rfoot{\thepage}
\setlength\parskip{1em}
\setlength\parindent{0em}

%% Titel og forfatter
\title{Den Store AV-bog}
\author{Søren Pilgård - DIKUrevyen}

%% Start dokumentet
\begin{document}

%% Vis titel
\maketitle
\newpage

%% Vis indholdsfortegnelse
\tableofcontents
\newpage

\section{Introduktion}
Dette er en introduktion til DIKUrevyens AV-system.
Systemet er udviklet af Søren Pilgård.

Systemet er på skrivende tidspunkt ikke færdigt men kan sagtens bruges til
normalt AVbrug.

Hvad skal man kunne for at bruge DIKUrevyens AV-system?

\begin{itemize}
\item \LaTeX
\item Linux
\item Emacs
\item Emacs Lisp
\item Python
\end{itemize}

\textbf{\LaTeX}\\
Bruges til at skrive selve overteksterne. Der bruges Beamer til at lave et langt
slideshow, overtex.sty definerer en række makroer der gør det let at lave en
lang præsentation.
De fleste på natfak burde kunne \LaTeX, hvis ikke er den mængde der bruges til
at lave normale overtekster ret lille og burde kunne mestres ved bare at kigge i
nogle af de gamle filer.

\textbf{Emacs}\\
Emacs bliver brugt som kontrolcenter til det hele.
Det er derfor væsentligt at have en hvis forståelse for hvordan Emacs virker.
Emacs er et voldsomt konfigurerbart program til at arbejde med tekst.
Jeg er selv stor Emacsbruger og har opbygget et helt unikt system.
På sigt er det håbet at lave en standard konfiguration som folk der ikke er
emacsbrugere kan udnytte. En sådan konfiguration ville kunne skjule at det
overhovedet er emacs der kører bag det hele.

\textbf{Emacs Lisp}\\
Emacs Lisp er det primære scripting sprog der bliver brugt.
Det bruges til at automatisere ting i Emacs, derudover kan der kaldes externe
kommandoer og kommunikere med andre maskiner.
Selve revysystemet bruger en stor del Emacs Lisp så hvis noget stopper med at
virke er det godt at kende. Til almindeligt AV brug kan man dog nøjes med en
stærkt begrænset del som denne guide nok skal introdusere.

\textbf{Linux}\\
DIKUrevyens AV-system er bygget og kører på linux styresystemet.
Det betydder at man for at bruge systemet effektivt er nød til at have en hvis
forståelse for at bruge en linuxmaskine igennem en terminal.
Et håb er en gang at have en form for standard opsætning af datamater hvor alt
nødvendigt er installeret, som AVmand skal man så blot sætte udstyrret op og
lave indholdet.

\textbf{Python}\\
Bliver brugt til de forskellige programmer og værktøjer der udgør resten af
AV-systemet.
Det burde kun være nødvendigt at kunne kode python for at udvikle/vedligeholde
systemet.


\newpage
\section{Tanken bag}
Den grundliggende filosofi bag systemet er at AV skal kunne komplementere en
revy men aldrig komme i vejen. Der skal dermed kun vises det som publikum skal
se/høre og intet andet.
Det virker utroligt amatøragtigt lige så snart publikum ser en cursor, en
film der maksimeres eller rammerne på et vindue.

Det simpleste AVsystem man kan lave er at have en datamat tilkoblet en
projektor. Datamaten kan derfra køre et presentationsprogram, f.eks. powerpoint.

\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      d [label="Datamat"];
      p [shape=trapezium, label="Projektor"];

      d -> p;
    }
  \end{dot2tex}
  \caption{Simpel AV opsætning.}
\end{figure}

Dette er dog ret primitivt.
Det er utroligt nemt at komme til at lave fejl så som at lige få skubbet
cursoren hen på et andet desktop eller at filmen spiller på den forkerte skærm.
Ting der er sket gang på gang til mange revyer, og som hurtigt får publikum til
at råbe ``TeXniken sejler!''.

Derudover har man et problem hvis man skal bruge mere end 1 projektor.

\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      d [label="Datamat"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];
      p3 [shape=trapezium, label="Projektor"];

      d -> p1;
      d -> p2;
      d -> p3;
    }
  \end{dot2tex}
  \caption{En datamat, flere projektorer.}
\end{figure}

\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      d1 [label="Datamat"];
      d2 [label="Datamat"];
      d3 [label="Datamat"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];
      p3 [shape=trapezium, label="Projektor"];

      d1 -> p1;
      d2 -> p2;
      d3 -> p3;
    }
  \end{dot2tex}
  \caption{Flere datamater, flere projektorer.}
\end{figure}

Man kan enten koble flere projektorer på en datamat, hvilket kræver en datamat
der er i stand til dette, hvilket ikke særligt mange er.
Alternativt kan man have flere datamater koblet til hver sin projektor.
Nu skal man så bare navigere rundt mellem en helt masse maskiner eller have en
AV-mand pr. maskine hvilket heller ikke er særligt praktisk.
Desuden har vi stadig problemet med at man let kommer til at dumme sig på samme
måde som i den første opsætning.

Det vi i virkeligheden ønsker os er en abstraktion mellem det at styrre AV og
det at vise AV. Hvis tingene kører adskilt og har klart definerede ansvars
områder kommer man ikke lige så let til at lave fejl. Vi ønsker derfor at have
en central maskine der styrer det hele, denne kommunikerer med andre maskiner
der sørger for at vise ting via projektorer.

\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      c [label="Kontrol datamat"];
      d1 [shape=box, label="Datamat"];
      d2 [shape=box, label="Datamat"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];

      c -> d1;
      c -> d2;
      d1 -> p1;
      d2 -> p2;
    }
  \end{dot2tex}
  \caption{Central styring, flere arbejdere med hver deres projektor.}
\end{figure}

Det er dette princip DIKUrevyens AVsystem benytter sig af.\\

Det første system blev lavet af Troels Henriksen.  Han lavede et
programmeringssprog \textit{Sindre} i Haskell til at lave grænseflader.  I det
sprog lavede han et \texttt{dmenu} lignende program kaldet \textit{sinmenu} som
han brugte som interface. Selve overteksterne bestod af en pdf som han lokalt
oversatte til rå tekst som blev fodret ind i et script der brugte hans
grænseflade. Dette script kommunikerede med en server koblet til en projektor
over en sshforbindelse.  \texttt{Xpdf} kan køres som en server der kan modtage
kommandoer fra en kommandolinje, på denne måde kunne man derfor styre
overtekster over ssh.

Desværre skalerede løsningen ikke særligt godt. Da der begyndte at komme mange
AVeffekter kunne man ikke både køre overtekster og andet AV alene.

Dette blev (i hvertfald forsøgt) rettet op på da jeg (Søren Pilgård) efterfølgende begyndte at skrive et nyt
AVsystem til DIKUrevyen 2012.
At skrive et AVsystem er dog ikke en nem tjans og det endte med at foregå i en
løbende process med forbedringer til hver revy.

Det nye AVsystem består af en centralt grænseflade der kan kommunikere med flere
forskellige maskiner der kan vise AV materiale.

Selve grænsefladen er udviklet som en række udvidelser til Emacs.
Grunden til dette er at da jeg startede indså jeg at systemet skulle kunne
følgende ting:
\begin{itemize}
\item Kommunikere med en server der viser indholdet.
\item Det skulle kunne vise ting overskueligt i en grafisk grænseflade.
\item Der skulle være mulighed for at indlejre scripts så man kan køre ting
  automatisk på bestemte steder i forestillingen.
\item Det ville være praktisk hvis man kunne rette fejl i texkoden mens man
  viste pdf'en da man ellers risikere at glemme dem.
\end{itemize}

Det gik hurtigt op for mig at det ville være fjollet at udvikle noget fra bunden
da Emacs i forvejen kunne meget af dette. Desuden er jeg Emacsmand og så hurtigt
hvordan en integration ville være nice.
Den grundliggende formel for at vise overtekster er at man åbner et LaTeX
dokument der bruger beamer pakken til at lave overteksterne. Så starter man
\texttt{ubertex}minor modet, dette sørger for at pdfen bliver lagt op på
serveren. Herefter skjules de fleste LaTeXkommandoer og et overlay lægges der
viser hvad der bliver vist. Man kan så trykke ``næste'' hvilket rykker overlayet ned
og synkroniserer serveren til at vise det tilsvarende slide i pdfen.
Man kan også trykke vilkårlige steder i tex filen og rykke direkter hertil i
overteksterne. Desuden kan der indsættes kode der eksekveres når man når til det
pågældende slide.

% TODO: billede

Derudover findes minormodet \texttt{uberscript} der lader en afvikle scripts.
Det kunne f.eks. være en sketch med en række lydeffekter eller et kald til en video.
Et script kunne også være aktoversigten hvorfra man ved at trykke ``næste''
kommer ind i det næste nummer, og når dette er færdigt kommer man så tilbage og
er klar til næste.

Hvis alt går som det skal, skal man som AVmand kun trykke på en knap (næste) for
at afvikle en revy.
Dette må være essensen af et godt AV system, når man kun skal tage sig af
timingen på skuespillerne/sangerne samt disses fejltagelser.

\section{Sådan er man en god AV mand}
\textit{TODO: Her kommer der til at være en række mere generele råd om hvordan
  man laver god AV}

\subsection{Om at lave gode overtekster}
% 6 ord
% Læser i høj grad på ordenes form.
% Drfr kn mn stdg lse dnne stnng
% Sætningen læses relativt hurtigt, men var den længere ville man skulle læse hele
% teksten.
% Man kan ca overskue

% <billede af en 4 lego brik>
% kan genkendes med det samme

% <billede af en 9'er lego klods>
% man skal tælle





% husk blanke slides

\newpage
\section{Opsætning af tekniken}
Til en standard opsætning ala DIKUrevyens skal du bruge:
\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      c [label="Kontrol datamat"];
      h [shape=octagon, label="LAN-hub"];
      d1 [shape=box, label="Brok"];
      d2 [shape=box, label="Intro"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];

      c -> h;
      h -> d1;
      h -> d2;
      d1 -> p1;
      d2 -> p2;
    }
  \end{dot2tex}
  \caption{Standard opsætning}
\end{figure}

Hvis det ønskes (Når det er færdigt) kan man køre med fjernstyrede projektorklapper.
\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      c [label="Kontrol datamat"];
      h [shape=octagon, label="LAN-hub"];
      a [shape=diamond, label="arduino"];
      d1 [shape=box, label="Brok"];
      d2 [shape=box, label="Intro"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];

      c -> h;
      h -> d1;
      h -> d2;
      h -> a;
      a -> p1;
      d1 -> p1;
      d2 -> p2;
    }
  \end{dot2tex}
  \caption{Standard opsætning, med arduino til projektorklap}
\end{figure}

\newpage
Systemet kan udvides, her ses f.eks. en opsætning med højtex (uden
projektorklapper) som brugt til DIKU Jubilæumsrevy.
\begin{figure}[h!]
  \centering
  \begin{dot2tex}
    digraph{
      rankdir=TD;
      node [shape=ellipse];
      c [label="Kontrol datamat"];
      h [shape=octagon, label="LAN-hub"];
      d1 [shape=box, label="Brok"];
      d2 [shape=box, label="Intro"];
      p1 [shape=trapezium, label="Projektor"];
      p2 [shape=trapezium, label="Projektor"];
      h0 [shape=box, label="left"];
      h1 [shape=box, label="mid"];
      h2 [shape=box, label="right"];
      hp0 [shape=trapezium, label="Projektor"];
      hp1 [shape=trapezium, label="Projektor"];
      hp2 [shape=trapezium, label="Projektor"];

      c -> h;
      h -> d1;
      h -> d2;
      d1 -> p1;
      d2 -> p2;

      h -> h0;
      h -> h1;
      h -> h2;
      h0 -> hp0;
      h1 -> hp1;
      h2 -> hp2;
    }
  \end{dot2tex}
  \caption{Højtex}
\end{figure}


\subsection{Kontrol}
Dette er din primære indgang til systemet. Jeg anbefaler at man bruger en
Foldedatamat, gerne ens egen bærbare.
En bærbar har den fordel at skærmen kan indstilles til både at sidde ned og stå
op. Derudover har den tastatur og mus indbygget så det ikke fylder i den ellers
rodede texnik. Og så kan man tage den med sig så man kan arbejde videre andre
steder. F.eks. er det praktisk at kunne plugge den ud så man kan arbejde videre
på sine overtekster til et ellers kedeligt senemøde i hyggehjørnet.


\subsection{Projektorer}
Til DIKUrevyen bruges der typisk i hvertfald 2 projektorer.
Der bruges én der peger op på lærredet over scenen, her vises der overtekster,
almindelige av-ting til sketches samt små film.

Kantinen ejer en stor Epson som bruges til introen/av på scenen

DIKUs projektorer bruges til alt andet.
DIKU har en række forskellige projektorer, hvor det kan være svært at kende
forskel på en del af dem.
%% TODO: udvid med mere konkrete råd om projektorer.

En god tradition, som en AV-mand bør holde i hævd, er at rense projektornes filtre
når man henter dem i begyndelsen af revyugen.
Der er tilsyneladende ikke andre der gør det, så lad det blive en del af
rutinen. Så overopheder de ikke lige så nemt.


Til projektorene er der bygget en række projektorkasser af gamle colakasser.
Disse gør det en del nemmere at indstille projektorene.\\
\textit{I gamle dage, da jeg var ond. Da blev projektorene stablet på bøger til
  de stod sirligt, den ærede AV-mand Troels Henriksen brugte mangt en stund på
  at bande og svovle når disse blev rykket}\\
Nu gør projektorkasserne det en del nemmere da man kan stripse/tape kasserne
fast og det hele bliver langt mere stabilt.
Desuden kan der komme langt mere luft til.\\
\textit{I gamle dage, da jeg var ond. Da blev projektorne så varme at de
  overophedede, så vi måtte til HCØ og hente tøris til køling. Det gav også
  kolde drikkevare (til tider frosne).}

Se afsnittene om Ubertex, Uberscript og Emacs for at finde ud af hvordan
softwaren bruges.

\subsubsection{Projektorklapper}
En ulempe ved projektore er at deres ``sorte'' ikke er mangel på lys, men bare
\textit{mindre} lys. Det betyder at når alt lyset i StUP1 er slukket og en
projektor står og lyser, er der stadig ret meget lys på scenen. Det ser
\textbf{MEGET} dumt ud og gør at man kan se hvad der sker på scenen.
Det er primært et problem for projektoren til overteksterne og kan accepteres
til f.eks. højtex (da loftet ikke er lige så reflekterende)

Det er desværre ikke en løsning at slukke/tænde projektorne da det tager for lang
tid/er besværligt/ skydder farver op når de tændes.

Derfor bruges en `projektorklap'. Der har i mange år været brugt en halv
papkasse på en stang. Det fungerer, men det kan godt være lidt stressene. Man
skal huske at få klappen på når man er færdig med en sang og har travlt med at
huske hvad der nu skal ske. Til tider sker det også at man glemmer at tage klappen
af, man når typisk at panikke lidt når der ikke kommer noget billede frem. Det
kan betyde at man misser de første par overtekster eller starten af en film.


For at løse dette er det planen at der bygges nogle arduinoer der kan kobles på netværket, disse
kontrolerer en klap foran projektoren. På denne måde kan projektoren automatisk
begynde at skyde billedet op på lærredet
Arduino ftw!

\subsection{Netværk}
\subsubsection{Statisk IP}
Hvis dit netværks interface hedder enp0s25
\begin{verbatim}
sudo ip link set enp0s25 up
sudo ip addr add 192.168.0.XXX/24 dev enp0s25
\end{verbatim}

alternativt
\begin{verbatim}
sudo ifconfig eth0 192.168.0.XXX
\end{verbatim}

\subsubsection{Hosts}
Da det kan være svært at huske alle ip-addreserne kan man i stedet navngive
maskinerne.
Dette gøres lokalt i \texttt{/etc/hosts}
et eksempel:

\begin{verbatim}
192.168.0.20    intro
192.168.0.30    brok
192.168.0.40    left
192.168.0.50    mid
192.168.0.60    right
\end{verbatim}

Nu kan man ssh'e ind ved blot at skrive:

\begin{verbatim}
ssh brok
\end{verbatim}

Det virker også med scp ol.

\subsubsection{Forbindelse uden login}
For at logge ind på systemerne over netværket bruges ssh.
Da det bliver jævnt irriterende hele tiden at skulle taste løsener kan man lægge
sin offentlige ssh nøgle ind på de forskellige maskiner
\begin{verbatim}
cat .ssh/authorized_keys | ssh revy@192.168.0.30 "cat >> ~/.ssh/authorized_keys"
\end{verbatim}
det kan være du først skal oprette mappen \texttt{.ssh}.

alternativt kan du bruge
\begin{verbatim}
ssh-copy-id revy@192.168.0.30
\end{verbatim}
Udskift \texttt{pilen} og ip'en med den relevante bruger og ip.
Husk at du skal have en ssh nøgle først
dannes med:

\begin{verbatim}
ssh-keygen
\end{verbatim}


\subsubsection{ssh mount}
I stedet for at scp'e alt muligt crap frem og tibage kan man benytte sig af et
ssh mount, som er et filsystem over ssh.
Jeg anbefaler at man har filerne liggende lokalt og fra hver maskine der skal
kommunikeres med køres \texttt{sshfs} som får filerne frem.

\textbf{Installer sshfs}
F.eks.:
\begin{verbatim}
sudo pacman -S sshfs}
\end{verbatim}

\textbf{fuse}
\texttt{sshfs} benytter fuse
\begin{verbatim}
sudo modprobe fuse
\end{verbatim}
\subsubsection{Gateway}
Hvis du er intereseret i at få internet på det lokale netværk kan man lave en
gateway.
Dette består i at en af datamaterne på det lokale netværk også er forbundet til
et netværk med internet, f.eks. eduroam.

Der er en guide på \url{sigkill.dk/writings/guides/gateway.html}

På gateway datamaten sættes først den statiske ip (allerede gjordt i forrige
trin)
Her efter køres gateway.sh som root (hentes på siden)

På clienterne der vil udnytte gatewayen sørger man først for at der er en
statisk ip.

herefter skrives
\begin{verbatim}
route add default gw 192.168.0.XXX
\end{verbatim}

eller
\begin{verbatim}
ip route add default via 192.168.0.XXX
\end{verbatim}
Hvor ``192.168.0.XXX'' er ip'en til gatewaymaskinen

herefter sættes en dns server, f.eks. google
\begin{verbatim}
echo nameserver 8.8.8.8 > /etc/resolv.conf
\end{verbatim}

Hvis dette ikke virker kan man evt. kigge på
\url{https://wiki.archlinux.org/index.php/Internet_Share} for en ip baseret løsning


\subsection{Arbejdere}
Arbejdere er de maskiner/servere der er sluttet til projektorne. Det er deres
rolle at vise AV-indholdet det kunne være overtekster, film, lydeffekter,
slides, billeder osv.

På nuværende tidspunkt bruges \texttt{mplayer} til at vise film, \texttt{feh}
til at vise billeder og \texttt{xpdf} til at vise pdf'er.
Det smarte ved \texttt{xpdf} er at det kan startes som en server som kan modtage
kommandoer via en terminal.

Ideen er at man fra sin kontroldatamat kan ssh'e ind på arbejderne og afvikle
den kommando man skal bruge. Emacs med ubertex/uberscript tilbyder basalt set et
interface til at gøre dette nemt.

Det er planen at programmet \texttt{Zeigen} udvikles.
Dette skal erstatte \texttt{feh} og \texttt{xpdf}.
I stedet for at skulle ssh'e ind lytter \texttt{Zeigen} til en port og udfører
kommandoer på givne klokkeslet. Så kan man sige ``om 1/2 sekund skal du afspille
denne video'' på 3 forskellige maskiner, hvorved videoen vises simultant via
\texttt{mplayer}.


Et eksempel på en arbejderdatamat er \texttt{brok} der bruges til overtekster og ting der
skal vises på lærredet.
Derudover findes \texttt{left}, \texttt{mid} og \texttt{right} der bruges til at vise \textit{højtex}.


\subsection{Brok}
\textbf{Her er en guide om at få brok til at virke:}

Sæt ham til
Projektor, tastatur, netværk og strøm.

Hvis der skal spilles lyd fra brok bør der være jord på da der ellers kan komme
en brummen.

Brok har på skrivende tidspunkt ubunut 11.04 natty.
Det betyder også at der er gnome, unity og ting og ækle sager på.
Disse har en tendens til at gøre livet surt, da de overskriver xorg
konfigurationer og gør mærkelige ting man ikke helt kan gennemskue.

\textit{Dette er \uline{IKKE} optimalt!
  Support til 11.04 udløb oktober 2012. Der bør installeres et ordentligt
  styresystem. UDEN gui (installeres seperat).}

\textbf{1: Tænd brok}\\
Brok logger automatisk ind med brugeren \textbf{\textit{revy}} med løsnet \textbf{\textit{hamster}}
Herefter starter unity der har en `kør' dialog ting.

\textbf{2: Start en terminal}\\
Skriv \code{terminal} og tryk enter.
Der vil nu komme en terminal op i hjørnet.

\textbf{3: Kom på netværket}\\
\begin{verbatim}
sudo ifconfig eth0 192.168.0.30
\end{verbatim}
Giv ham en passende ip du kan huske.

\textbf{4: Opret SSH forbindelse}
Der kører allerede en ssh daemon.
forbind til \textbf{\textit{revy}} med løsnet \textbf{\textit{hamster}}.
Du kan evt. uploade din offentlige ssh-nøgle så du slipper for at logge ind.
\begin{verbatim}
ssh revy@192.168.0.30
\end{verbatim}

\textbf{5: Stop gdm}\\
Gnome Desktop Manager skal lukkes.
\begin{verbatim}
sudo service gdm stop
\end{verbatim}
Dette lukker hele den grafiske grænseflade, inklusiv X.

\textbf{6: Start screen}\\
\begin{verbatim}
screen
\end{verbatim}
screen køres så vi kan starte X i baggrunden.
Når programmet startes vises der en menutekst, bare tryk enter.
\texttt{screen} kører nu.

\textbf{7: startx}\\
Start X manuelt.
\begin{verbatim}
startx
\end{verbatim}
Dette starter X op hvorefter .xinitrc eksekveres.

Som det er lige nu startes \texttt{xmonad} som windowmanager.
Det betyder at skærmen pr. default er sort når x er startet


\textbf{8: detach fra screen}\\
Tryk \texttt{Ctrl-a d}. Dette lader alt der kører i screen fortsætte upåvirket
mens du kommer tilbage til det forrige miljø.
for at reattache skriv da \code{screen -r}.

\textbf{9: test xmonad}\\
Test om xmonad virker. På broks tastatur trykkes \texttt{Alt-Shift-Enter}.
En terminal burde åbne sig.
Luk igen med \texttt{Alt-Shift-c}.

\textit{Læs evt. afsnitet om xmonad.}

Da terminalen er en default \texttt{xterm} med hvid baggrund er dette et snedigt trick
til at se hele området projektoren kan lyse op.
Jeg bruger dette ofte når jeg tweaker projektoren.



\textbf{10: prøv ting af}
Med en ssh forbindelse åben, lad os prøve om vi kan få noget til at virke.
Start med at vælge det `display' der skal vises grafiske ting på
\begin{verbatim}
export DISPLAY=:0
\end{verbatim}
Dette skal køres for hver gang du ssh'er ind.

start nu xpdf med en af de gamle overtekst filer der ligger et eller andet sted.

Se sektionen om kommandoer for nærmere detaljer

Hvis man gerne vil lave flere ting simultant på brok kan man sagtens åbne flere
lokale terminaler og ssh'e ind parallelt.




\subsubsection{Ting der køres på brok}
For at hacke uden om alt muligt gøjl køres et par scripts gennem
\texttt{.xinitrc}

\textbf{swarp}\\
\texttt{swarp} er et program der flytter musse-markøren (cursoren) til et givent koordinat.
Swarp findes på \url{tools.suckless.org/swarp}.
\texttt{swarp} findes desuden i arch's repository, det kan være den også findes til
debian baserede styresystemer, potientielt i en suckless pakke.

\texttt{swarp} køres på brok med argumenterne 20000 20000, hvilket flytter
markøren ad helvede til.

istedet for \texttt{swarp} kan man bruge \texttt{unclutter}
med kommandoen \code{unclutter -idle 0 -root \&}
Som i fjern cursoren efter 0 sekunders delay efter bevægelse inklusiv når
cursoren er over rod baggrunden (altså ikke kun over vinduer).

\textbf{fixsleep}
\texttt{fixsleep.sh} er et script der forsøger at forhindre X i at slukke skærm outputet.
X bruger et system der hedder DPMS (Display Power Management Signaling) til
automatisk at slukke skærm outputet efter en periode uden tastaturaktivitet.

fixsleep benytter følgende to kommandoer
\begin{verbatim}
xset dpms 0 30000 40000
xset s 30000
\end{verbatim}
den første linje dækker over \texttt{xset dpms [standby [suspend [off]]]}
den anden linje dækker over \texttt{xset s [timeout [cycle]]}

\textbf{keepon}
\begin{verbatim}
xset dpms force on
\end{verbatim}
Denne kommando forcer dpms fra, (det svarer til at at trykke på en tast)

\texttt{keepon.sh} er et script der ligger i baggrunden og kører denne kommando
whert 30 sekund.


fixsleep og keepon forsøger begge at holde dpms stangen ved at lave aktivitet.
Man kan måske istedet bruge
\begin{verbatim}
xset -dpms; xset s off
\end{verbatim}
Til at slå dpms fra.
De to systemer kan dog \uline{ikke} blandes.

Man kan se om dpms er slået til ved at kalde \code{xset -q}
\subsection{Xmonad}
Windos/super eller alt som modifier knap.

\section{Komandoer}

\subsection{xpdf}
Overtekster køres i xpdf der åbnes manuelt med:
\begin{verbatim}
xpdf -remote ubertex -fullscreen -mattecolor black -fg black
    -bg black -papercolor black filnavn
\end{verbatim}
Da dette er meget langt kan man istedet bruge aliaset
\begin{verbatim}
p filnavn
\end{verbatim}


\subsection{mplayer}
Til at vise videoer manuelt bruges mplayer:
\begin{verbatim}
mplayer -nolirc -msglevel all=-1 -msglevel statusline=5
    -vo gl2 -autosync 30 -cache 1048576
    -cache-min 99:100 -xy 500 -geometry 49%:40% filnavn
\end{verbatim}
eller aliaset
\begin{verbatim}
m filnavn
\end{verbatim}

\subsubsection{Positionering af mplayer}
\textit{TODO: Noget om positionering af mplayer her}

\section{Konvertering fra manuskrift til overtekster}
\section{ubertex}
\section{ubersicht}
\section{Zeigen}
Zeigen er et program til at køre andre programmer kaldet ``sketches''.
\section{Herzog}

\section{furst}
\section{Hvordan virker koden}

Der sørges automatisk for at det korrekte major mode køres på .tex og .el filer

\section{FAQ}
Ubertex tager ikke højde for pauser i comments, latex gør.

\subsection{\LaTeX{}}
\subsubsection{File `overtex.sty' not found.}
\texttt{overtex.sty} er en fil hvori de overtex speciffike kommandoer er
defineret. \texttt{revy-manus-prepare} indsætter automatisk
\code{\textbackslash{}usepackage\{overtex\}} i overtexfilerne. Når man kalder
\texttt{revy-compile-tex} specificeres automatisk hvor denne fil findes. Kaldes
pdflatex manuelt ved den ikke hvor denne fil findes.
Den simpleste løsning er at oversætte med et kald til \texttt{revy-compile-tex}.

Alternativt kan man enten kopiere \texttt{overtex.sty} ind i mappen hvor \texttt{.tex}
filen ligger, sætte shell variablen \texttt{TEXINPUTS} til at indeholde mappen hvori
\texttt{overtex.sty} ligger eller kopiere filen ind i
\texttt{\~{}/texmf/tex/latex/overtex/overtex.sty} hvor den vil være synlig for oversætteren.

\section{Værktøjer}
\subsection{Schneider}
\textit{Tysk: Skrædder}

\textbf{Dependencies:}
\begin{itemize}
\item Python3
\item ffmpeg
\end{itemize}

Schneider er et værktøj til at skære film og billeder op til at kunne blive vist over flere
projektorer.

Schneider kan på skrivende stund kun dele medier op i flere snit ved siden af
hinanden og ikke over under. Det burde dog være let at rette til.

\subsection{Zeitherr}
\textit{Tysk: Timelord}
Er en bastardiseret udgave af en NTP tidsserver til at holde de forskellige
maskiner synkroniseret.

\subsection{Zeigen}

\section{Problemer/løsninger}
\subsection{Der er lag/forsinkelser}
Lag er irriterende, det opleves primært som en forsinkelse fra man har trykket
på knappen til der sker noget på projektoren. Det er et problem når man skal
lave overtekster.

Til DIKUs jubilæumsrevy var der ca. et sekunds forsinkelte fra jeg trykkede til
at overteksterne blev vist. Jeg har ikke definitivt fundet fejlen endnu men der
bliver arbejdet på det.

Her er først nogle metoder til at lokalisere hvor omtrentligt forsinkelsen
opstår.
Det er mere eller mindre umuligt at lave konkrete målinger så det er noget man
må føle sig frem til (Super naturvidenskabelig metode!).\\
\textit{Følgende tager udgangspunkt i Xpdf, men gøres på samme måde med Zeigen}

Prøv først at sætte systemet til at køre alt lokalt. Aka, kør både Emacs og Xpdf
lokalt og der kommunikeres via ssh til \texttt{localhost}. Hvis forsinkelsen
stadig er der, er fejlen enten i Emacs, i Xpdf, eller i den lokale
hardware.

Mine erfaringer med Xpdf er dog at det ikke er her fejlen ligger.
Prøv nu at starte Xpdf på serveren og ssh ind på denne, giv nu manuelt Xpdf
ordre til at skifte slide.

Min erfaring er at det er meget tilfældigt hvad der præcist sker. Jeg oplevede
at delayed forsvandt efter jeg gjorde ovenstående, også det mellem Emacs og
Xpdf, men kun indtil Xpdf blev lukket.

Det virker også til at Xpdf bliver langsommer afhængigt af længden af
overteksterne og ikke nødvendigvis størrelsen af pdfen.

Jeg ved ikke helt hvordan dette skal løses.
Det er en af grundene til at vi vil lave vores egen fremviser (Zeigen).

\appendix
\section{En guide til Linux}
% Sådan bruger du en terminal
\textbf{cd}
\textbf{ls}
\textbf{cp}
\textbf{mv}

\textbf{ip}
\textbf{ssh}
\textbf{nano}

\section{Installation af Arch Linux}
\begin{verbatim}
loadkeys colemak
ip link show
ip link set enpXsX up
ip route add default via 192.168.0.XXX
echo nameserver 8.8.8.8 > /etc/resolv.conf
\end{verbatim}

\begin{verbatim}
ping google.com
\end{verbatim}
\textit{tryk Ctrl-c for at stoppe.}

\begin{verbatim}
cgdisk /dev/sdX
\end{verbatim}

Formententligt \texttt{sd\textbf{a}}

Tryk enter.

\texttt{Delete} alle partitoner.

\textbf{Lav plads til GPT partition}
\textit{Dette giver plads ti en partions tabel til grub}\
\begin{enumerate}
\item \texttt{New}
\item Tryk enter, first sector skal bare  være default.
\item \texttt{1007KiB} enter
\item \texttt{ef02} enter
\item Tryk enter, der behøver ikke at være et navn
\end{enumerate}

\textbf{Lav swap}
\textit{Dette er næppe nødvendigt, men jeg laver den af gammel vane}
\begin{enumerate}
\item Tryk ned.
\item \texttt{New}
\item Tryk enter, default er fint, formententligt 2048.
\item \texttt{3G} mindre swap kan også vælges (eller udelades).
\item \texttt{8200} swap Hex koden.
\item tryk enter.
\end{enumerate}

\textbf{Lav en partition}
\begin{enumerate}
\item Tryk ned.
\item \texttt{New}
\item enter
\item enter
\item enter
\item enter
\end{enumerate}

Vælg \texttt{Write}, skriv \texttt{yes}.
Nu kan der stå at den gamle partitionstabel stadig er i brug.
Afslut, genstart og udfør alle trinene inden \texttt{cgdisk} igen.

Når du er klar igen skal vi lave nogle filsystemer.
\begin{verbatim}
lsblk
\end{verbatim}
For at få overblik

\begin{verbatim}
mkfs.ext4 /dev/sda3
mkswap /dev/sda2
swapon /dev/sda2
\end{verbatim}

Ignorer sda1 indtil videre.

\begin{verbatim}
mount /dev/sda3 /mnt
\end{verbatim}

Hvis du skulle have lavet en seperat partition til home så lav en mappe
\code{mkdir /mnt/home} og mount home partitionen der \code{mount /dev/sdaX
  /mnt/home}.

Sørg for at være på nettet da vi nu skal hente pakker ned til styresystemet.
\begin{verbatim}
pacstrap -i /mnt base
\end{verbatim}
Tryk enter til spørgsmål.

\begin{verbatim}
genfstab -U -p /mnt >> /mnt/etc/fstab
arch-chroot /mnt /bin/bash
nano /etc/locale.gen
\end{verbatim}

Fjern kommenteringen til linjerne \textit{\#da\_DK.UTF-8 UTF-8} og\textit{\#en\_US.UTF-8 UTF-8}

\begin{verbatim}
locale-gen
echo LANG=en_US.UTF-8 > /etc/locale.conf
export LANG=en_US.UTF-8
ln -s /usr/share/zoneinfo/Europe/Copenhagen /etc/localtime
hwclock --systohc --utc
echo XXX > /etc/hostname
\end{verbatim}
hvor XXX er navnet til maskinen

\begin{verbatim}
mkinitcpio -p linux
\end{verbatim}
\begin{verbatim}
passwd
\end{verbatim}
Skriv løsn til root.

\begin{verbatim}
pacman -S grub
grub-install --target=i386-pc --recheck --debug /dev/sda
grub-mkconfig -o /boot/grub/grub.cfg
exit
umount -R /mnt
shutdown -h now
\end{verbatim}
Hiv usbstikket ud.

Tænd datamaten igen.
Hvis du som mig til jubilæumsrevyen installerede systemet på en harddisk i en
anden datamat en dens egen, kan det være at ramdisken fejler, i grub vælges da
fallback løsningen og du kalder \code{mkinitcpio -p linux} for at skabe et nyt
korrekt image.

\begin{verbatim}
ip link show
\end{verbatim}
For at se netværks interfacet

\begin{verbatim}
useradd -m -s /bin/bash revy
\end{verbatim}
\begin{verbatim}
passwd revy
\end{verbatim}
Giv revy et løsn.


\begin{verbatim}
su revy
nano /home/revy/lan.sh
\end{verbatim}
indtast
\begin{verbatim}
ip link set enpXsX up;
ip addr add 192.168.0.XXX/24 dev enpXsX;

ip route add default via 192.168.0.YYY;
echo nameserver 8.8.8.8 > /etc/resolv.conf;
\end{verbatim}
Gem, luk nano og skriv \code{exit}.

\begin{verbatim}
pacman -S sudo
visudo
\end{verbatim}
Tryk pil ned til du finder linjen
\begin{verbatim}
root ALL=(ALL) ALL
\end{verbatim}
placer cursoren under denne og tryk \texttt{i}
tast \texttt{revy ALL=(ALL) ALL} tryk enter, tryk escape
tryk \text{:wq} enter.

revy kan nu sudo'e.

\begin{verbatim}
pacman -S openssh
\end{verbatim}
\begin{verbatim}
systemctl enable sshd.service
systemctl start sshd
\end{verbatim}
Nu kan vi ssh'e ind fra vores lokale maskine \code{ssh revy@192.168.0.XXX}.
\textit{Læs evt. afsnittet om ssh-nøgler.}

Nu kan vi vælge at køre ting via ssh forbindelse.


Nu skal vi installere pakker
\begin{verbatim}
pacman -S xorg-server xorg-server-utils xorg-xinit
\end{verbatim}

Der skal formententligt installeres nogle grafik drivere, følgende er nogle
udemærkede open source standard drivere

\begin{verbatim}
pacman -S mesa xf86-video-vesa
\end{verbatim}

Der kan kun køre én instans af pacman af gangen.
Så sæt ham til at arbejde mens vi i en anden terminal begynder at konfigurere.
\begin{verbatim}
pacman -S xmonad xmonad-cotrib alsa-utils rxvt-unicode feh mplayer ttf-dejavu
\end{verbatim}

I en terminal anden åbner du \texttt{.xinitrc} og skriver aller nederst:
\begin{verbatim}
exec xmonad
\end{verbatim}

Åben så \texttt{lan.sh} og i bunden tilføjer du
\begin{verbatim}
xset -dpms; xset s off
\end{verbatim}

Åben \texttt{.bashrc} og tilføj i bunden:
\begin{verbatim}
if [[ -z $DISPLAY && $(tty) = /dev/tty1 ]]; then
    exec startx
fi
\end{verbatim}
Du kan evt. også tilføje følgende alias:
\begin{verbatim}
alias d='export DISPLAY=:0'
\end{verbatim}

\section{Stripped Emacs}
\section{Emacs}
\section{mangler}
revy-shell skal escape kommandoer
Youtube
Arduinoer
Stripped Emacs

\section{Zeigen-protokol}

ADVARSEL beskeder til sketches er lokale for den nuværende eksekverende sketch!!!.

Zegien forstår følgende protokol:

\begin{verbatim}
host [otherhost];<time>;command;options
\end{verbatim}

\texttt{Host} er en mellemrums adskilt liste af navne på de zeigen servere/grupper der
skal have beskeden (tage sig af den). Husk at navne er caseinsensitive.

\texttt{<time>} er klokkeslettet hvor kommandoen skal udføres.
Beskeder i datiden udføres hurtigst muligt, så brug 0 hvis den skal udføres med
det samme.

\texttt{command} er den kommando der ønskes udført
\begin{verbatim}
clearqueue
kill
quit
sketch
start
sync
\end{verbatim}

\texttt{options} er argumenter der gives til kommandoen.
formattet for \texttt{options} afgøres af kommandoen

\subsection{kill}
Lukker den nuværende sketch.

Man kan give ét argument med og kommandoen udføres kun hvis sketchens navn
matcher dette.

Sketchens navn er Ikke casesensitiv.

\subsection{Start}
Start lukker den nuværende sketch og starter en ny.

Man kan give ét argument med og kommandoen udføres kun hvis sketchens navn
matcher dette.

\subsection{Sketch}
\texttt{sketch} kommandoen regner med at option består af følgende
\begin{verbatim}
sketchname;message
\end{verbatim}

Hvis \texttt{sketchname} tilsvarer navnet på den nuværende afviklende sketch,
sendes \texttt{message} til sketchen på det før angivne tidspunkt.
Beskeden modtages i sketchens \textit{receive} metode.

\section{PDF/billedviser}
Kan baseres på poppler.
python-poppler-qt4?

mupdf er et mere minimalistisk/optimeret alternativ til xpdf's poppler.
har mudraw der kan rendere til png.

\end{document}
